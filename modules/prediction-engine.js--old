const { 
  getAllRelatedJodis, 
  getAllRelatedPattis, 
  calculateCutPatti, 
  getPattiFamily,
  getTopPattisFromFamily,
  getTopIndexes,
  isRecent
} = require('../utils/helpers');
const { PATTI_FAMILIES, JODI_FAMILIES } = require('../config/constants');
const patternAnalyzer = require('./pattern-analyzer');

// Enhanced Panel-Based Jodi Prediction
const generateEnhancedPanelJodis = (panelAnalysis, topN = 15) => {
  const { jodiPanelStats } = panelAnalysis;
  
  const panelPredictions = Array.from(jodiPanelStats.entries())
    .map(([jodi, stats]) => {
      const hitRate = stats.hits / stats.appearances;
      const frequency = stats.appearances;
      const recency = stats.lastSeen;
      
      // Enhanced scoring formula
      const baseScore = hitRate * 100;
      const frequencyBonus = Math.log(frequency + 1) * 10;
      const recencyBonus = (1 / recency) * 50;
      
      const confidence = baseScore + frequencyBonus + recencyBonus;
      
      return {
        jodi,
        hitRate: Math.round(hitRate * 100),
        frequency,
        recency,
        confidence: Math.round(confidence * 100) / 100
      };
    })
    .filter(p => p.frequency >= 2 && p.hitRate >= 5)
    .sort((a, b) => b.confidence - a.confidence)
    .slice(0, topN);
  
  return panelPredictions;
};

// Enhanced Panel-Based Ank (Patti) Prediction
const generateEnhancedPanelPattis = (panelAnalysis, type = 'open', topN = 20) => {
  const panelStats = type === 'open' ? panelAnalysis.openPattiPanelStats : panelAnalysis.closePattiPanelStats;
  
  const panelPredictions = Array.from(panelStats.entries())
    .map(([patti, stats]) => {
      const hitRate = stats.hits / stats.appearances;
      const frequency = stats.appearances;
      const recency = stats.lastSeen;
      const roleSpecific = type === 'open' ? stats.asOpen : stats.asClose;
      const roleRate = roleSpecific / stats.appearances;
      
      // Enhanced scoring for patti
      const baseScore = hitRate * 100;
      const frequencyBonus = Math.log(frequency + 1) * 15;
      const recencyBonus = (1 / recency) * 60;
      const roleBonus = roleRate * 40;
      
      const confidence = baseScore + frequencyBonus + recencyBonus + roleBonus;
      
      return {
        patti,
        hitRate: Math.round(hitRate * 100),
        frequency,
        recency,
        roleSpecific: type === 'open' ? stats.asOpen : stats.asClose,
        roleRate: Math.round(roleRate * 100),
        confidence: Math.round(confidence * 100) / 100,
        cutPatti: calculateCutPatti(patti),
        family: getPattiFamily(patti)
      };
    })
    .filter(p => p.frequency >= 2 && p.hitRate >= 3)
    .sort((a, b) => b.confidence - a.confidence)
    .slice(0, topN);
  
  return panelPredictions;
};

// Combined Prediction Engine
const generateCombinedPredictions = (data, daysLimit = 30) => {
  // 1. Panel-based analysis
  const panelAnalysis = patternAnalyzer.generatePanelBasedPredictions(data, daysLimit);
  
  // 2. Panel-based jodis
  const panelJodis = generateEnhancedPanelJodis(panelAnalysis, 20);
  
  // 3. Panel-based pattis for open and close
  const panelOpenPattis = generateEnhancedPanelPattis(panelAnalysis, 'open', 25);
  const panelClosePattis = generateEnhancedPanelPattis(panelAnalysis, 'close', 25);
  
  // 4. Pattern-based predictions
  const patternAnalysis = patternAnalyzer.analyzePatternBasedPredictions(data, daysLimit);
  
  // 5. Combine all predictions with scoring
  const combinedJodis = combineJodiPredictions(panelJodis, patternAnalysis, data);
  const combinedPattis = combinePattiPredictions(panelOpenPattis, panelClosePattis, data);
  
  return {
    panelJodis: combinedJodis,
    panelOpenPattis: combinedPattis.open,
    panelClosePattis: combinedPattis.close,
    patternAnalysis,
    panelAnalysis
  };
};

// Combine jodi predictions with weights
const combineJodiPredictions = (panelJodis, patternAnalysis, data) => {
  const scoredJodis = new Map();
  
  // Add panel-based jodis with high weight
  panelJodis.forEach((jodi, index) => {
    const weight = 100 - (index * 3);
    scoredJodis.set(jodi.jodi, (scoredJodis.get(jodi.jodi) || 0) + weight);
  });
  
  // Add pattern-based jodis
  patternAnalysis.sequential.forEach(jodi => {
    scoredJodis.set(jodi, (scoredJodis.get(jodi) || 0) + 25);
  });
  
  patternAnalysis.repeating.forEach(jodi => {
    scoredJodis.set(jodi, (scoredJodis.get(jodi) || 0) + 30);
  });
  
  patternAnalysis.mirrorPatterns.forEach(jodi => {
    scoredJodis.set(jodi, (scoredJodis.get(jodi) || 0) + 35);
  });
  
  // Add family sequence predictions
  patternAnalysis.familySequences.forEach(seq => {
    const familyJodis = JODI_FAMILIES[seq.predictedFamily] || [];
    familyJodis.forEach(jodi => {
      scoredJodis.set(jodi, (scoredJodis.get(jodi) || 0) + (40 * seq.confidence));
    });
  });
  
  // Convert to array and sort
  return Array.from(scoredJodis.entries())
    .map(([jodi, score]) => ({ jodi, score: Math.round(score) }))
    .sort((a, b) => b.score - a.score)
    .slice(0, 15);
};

// Combine patti predictions
const combinePattiPredictions = (panelOpenPattis, panelClosePattis, data) => {
  const scoredOpenPattis = new Map();
  const scoredClosePattis = new Map();
  
  // Score open pattis
  panelOpenPattis.forEach((patti, index) => {
    const weight = 120 - (index * 4);
    scoredOpenPattis.set(patti.patti, weight);
  });
  
  // Score close pattis
  panelClosePattis.forEach((patti, index) => {
    const weight = 120 - (index * 4);
    scoredClosePattis.set(patti.patti, weight);
  });
  
  // Cross-reference bonus (pattis that appear in both lists)
  panelOpenPattis.forEach(openPatti => {
    if (panelClosePattis.some(closePatti => closePatti.patti === openPatti.patti)) {
      scoredOpenPattis.set(openPatti.patti, (scoredOpenPattis.get(openPatti.patti) || 0) + 50);
      scoredClosePattis.set(openPatti.patti, (scoredClosePattis.get(openPatti.patti) || 0) + 50);
    }
  });
  
  return {
    open: Array.from(scoredOpenPattis.entries())
      .map(([patti, score]) => ({ patti, score }))
      .sort((a, b) => b.score - a.score)
      .slice(0, 20),
    close: Array.from(scoredClosePattis.entries())
      .map(([patti, score]) => ({ patti, score }))
      .sort((a, b) => b.score - a.score)
      .slice(0, 20)
  };
};

// Generate family and jodi-based guesses
const generateGuesses = (analysis, daysLimit) => {
  const { digitFrequency, openSumFrequency, closeSumFrequency, pattiFrequencyMap, data } = analysis;

  // Get frequent digits
  const frequentDigits = digitFrequency
    .map((count, digit) => ({ digit, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 5)
    .map(item => item.digit);

  const topOpenSums = getTopIndexes(openSumFrequency, 3);
  const topCloseSums = getTopIndexes(closeSumFrequency, 3);
  
  // Enhanced jodi analysis
  const jodiPredictions = generateEnhancedJodiPredictions(data, 8);
  const topJodis = jodiPredictions.topJodis;

  // Combined panel-based predictions
  const combinedPredictions = generateCombinedPredictions(data, daysLimit);

  const topOpenFamilies = topOpenSums.map(sum => ({
    sum,
    patti: getTopPattisFromFamily(PATTI_FAMILIES[sum] || [], pattiFrequencyMap, 6)
  }));

  const topCloseFamilies = topCloseSums.map(sum => ({
    sum,
    patti: getTopPattisFromFamily(PATTI_FAMILIES[sum] || [], pattiFrequencyMap, 6)
  }));

  // Combine and filter based on frequent digits
  const allGuesses = new Set();
  [...topOpenFamilies, ...topCloseFamilies].forEach(f => {
    if (f.patti && f.patti.length > 0) {
      f.patti.forEach(p => allGuesses.add(p));
    }
  });

  // Filter guesses that contain at least one frequent digit
  let top5Guesses = Array.from(allGuesses).filter(patti =>
    frequentDigits.some(d => patti.includes(d.toString()))
  ).slice(0, 5);

  // Fallback if no guesses
  if (top5Guesses.length === 0) {
    top5Guesses = ['127', '136', '145', '128', '137'].slice(0, 5);
  }

  // Generate jackpot predictions
  const jackpotPredictions = generateAccurateJackpotPredictions(
    analysis, 
    topOpenFamilies, 
    topCloseFamilies, 
    top5Guesses,
    topJodis,
    data,
    daysLimit
  );

  return {
    frequentDigits,
    topOpenSums,
    topCloseSums,
    topOpenFamilies,
    topCloseFamilies,
    topJodis,
    jodiAnalysis: jodiPredictions.detailedAnalysis,
    combinedPredictions,
    top5Guesses,
    jackpotPredictions
  };
};

// Enhanced Jodi Prediction (simplified for module)
const generateEnhancedJodiPredictions = (data, topN = 8) => {
  // This would contain the jodi analysis logic from your original code
  // Simplified for this example
  const scoredJodis = {};
  
  // Score jodis based on frequency and patterns
  data.forEach(day => {
    const jodi = day.jodi;
    scoredJodis[jodi] = (scoredJodis[jodi] || 0) + 1;
  });
  
  const finalJodis = Object.entries(scoredJodis)
    .sort((a, b) => b[1] - a[1])
    .slice(0, topN)
    .map(([jodi]) => jodi);

  return {
    topJodis: finalJodis,
    detailedAnalysis: []
  };
};

// Jackpot prediction
const generateAccurateJackpotPredictions = (analysis, topOpenFamilies, topCloseFamilies, top5Guesses, topJodis, data, daysLimit) => {
  const { pattiFrequencyMap } = analysis;
  
  const jackpotCandidates = new Set();
  
  // Add all pattis from top open and close families
  topOpenFamilies.forEach(family => {
    family.patti.forEach(patti => jackpotCandidates.add(patti));
  });
  
  topCloseFamilies.forEach(family => {
    family.patti.forEach(patti => jackpotCandidates.add(patti));
  });
  
  // Add cut pattis of top guesses
  top5Guesses.forEach(patti => {
    const cutPatti = calculateCutPatti(patti);
    jackpotCandidates.add(cutPatti);
  });
  
  // Recent patterns
  const recentPatterns = patternAnalyzer.analyzeRecentPatterns(data, daysLimit);
  recentPatterns.forEach(patti => jackpotCandidates.add(patti));
  
  // Score candidates
  const scoredCandidates = Array.from(jackpotCandidates).map(patti => {
    const frequency = pattiFrequencyMap[patti] || 0;
    let score = frequency * 10;
    
    if (top5Guesses.includes(patti)) score += 1000;
    if (isRecent(patti, data, 7)) score += 500;
    if (isRecent(patti, data, 30)) score += 200;
    
    const inOpenFamilies = topOpenFamilies.some(family => family.patti.includes(patti));
    const inCloseFamilies = topCloseFamilies.some(family => family.patti.includes(patti));
    
    if (inOpenFamilies && inCloseFamilies) score += 300;
    else if (inOpenFamilies || inCloseFamilies) score += 150;
    
    return {
      patti,
      cutPatti: calculateCutPatti(patti),
      score: Math.round(score),
      frequency,
      inTopGuesses: top5Guesses.includes(patti)
    };
  });
  
  scoredCandidates.sort((a, b) => b.score - a.score);
  
  return {
    topJackpotPattis: scoredCandidates.slice(0, 20).map(p => p.patti),
    topJackpotJodis: topJodis,
    detailedPattiInfo: scoredCandidates.slice(0, 10)
  };
};

module.exports = {
  generateCombinedPredictions,
  generateGuesses,
  generateEnhancedPanelJodis,
  generateEnhancedPanelPattis
};